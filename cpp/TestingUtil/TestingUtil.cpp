/* ***************************************************************
\\ File Name:  TestingUtil.cpp
// Created By: Nick G. Toth
\\ E-Mail:     ntoth@pdx.edu
// Date:       August 13th, 2017
\\
// Overview: This file contains implementations for several general
\\ unit testing tools. Include TestingUtil.h for usage.
// namespace tu.
\\
// ***************************************************************/

#include "TestingUtil.h"


/* *************************************************
// Load in menu options from an external file,
\\ generate printable cli menu. See TestMenu.txt
// for menu option syntax.
\\
// @param filename: File containing menu options.
\\
// *************************************************/
std::unique_ptr<std::string[]> tu::generateMenu(std::string filename)
{
  // Open the given file.
  std::ifstream menu_opts(filename);

              // Buffer for reading in lines for the menu.
  std::string LINE_BUFFER = "",
              // Buffer for the size (in options) of the menu.
              // Specified by a line in the header of the menu
              // option text file formatted: "#00". It is assumed
              // that no menu will need more than 99 options.
              OPT_BUFFER = "";

        // Index counter for traversing lines,
        // and for counting lines added to menu.
  short ch_cnt = 0,
        // Counter for the number of menu options.
        opt_cnt = 0;

  // While there are unread lines..
  while(menu_opts.good() && opt_cnt != 1)
  {
    // Read in the current line.
    std::getline(menu_opts, LINE_BUFFER);

    // If the current line specifies the number of
    if(LINE_BUFFER != "" && LINE_BUFFER[ch_cnt] == '#')
    {
      // Copy over any numeric characters (up to two) after
      // the pound character in LINE_BUFFER to OPT_BUFFER.
      while(ch_cnt < 2 && std::isdigit(LINE_BUFFER[ch_cnt + 1]))
      {
        OPT_BUFFER = OPT_BUFFER + LINE_BUFFER.at(ch_cnt + 1);
        ++ch_cnt;
      }

      // Set opt_cnt to 1 to exit loop.
      opt_cnt = 1;
    }
  }

  // If no size was specified, report failure.
  if(ch_cnt == 0) return std::unique_ptr<std::string[]>(nullptr);

  // Convert the option count buffer into a number.
  opt_cnt = std::stoi(OPT_BUFFER);

  // Allocate memory for a string to menu for each specified 
  // menu option, plus one for storing the number of options.
  std::unique_ptr<std::string[]> menu(new std::string[ opt_cnt + 1 ]);

  // Store the number of options in the menu.
  menu[0] = OPT_BUFFER;

  // Update opt_cnt to match the number of menu options.
  ++opt_cnt;
  // Reset ch_cnt to 1 for counting added menu options..
  ch_cnt = 1;

  // While there are unread lines..
  while(menu_opts.good())
  {
    // Read in the current line.
    std::getline(menu_opts, LINE_BUFFER);

    // If the current line is not a comment..
    if(LINE_BUFFER != "" && LINE_BUFFER.at(0) != '%' && ch_cnt < opt_cnt)
    {
      // Copy the contents of the menu line into the next menu index.
      menu[ch_cnt] = LINE_BUFFER;
      // Increment the menu option counter.
      ++ch_cnt;
    }
  }

  return move(menu);
}



/* *************************************************
// General controller for the menu generated by
\\ generateMenu().
//
\\ @param menu: The menu being controlled by this
// function.
\\
// *************************************************/
int tu::menuController(std::unique_ptr<std::string[]> const & menu)
{
  // If an NULL menu is passed in, report failure.
  if(!menu) return -1;

  // Read the number of options in
  // the menu from its first index.
  int options = std::stoi(menu[0]);

      // User's selection to be returned.
  int selection = 0,
      // Counter for displaying menu lines.
      line = 1;

  // Display the menu.
  for(; line <= options && menu[line] != ""; ++line)
    std::cout << "\n  [" << line << "] => " << menu[line];

  // Store the number of displayed options.
  options = line - 1;

  // If no options were displayed, report failure.
  if(options == 0) return -1;

  // If the user's selection has not been read in, or
  // was invalid, read in the user's menu selection.
  while(selection < 1 || selection > options)
  {
    // Prompt the user to enter a selection
    std::cout << "\n\n  Enter the number corresponding to your selection: ";

    // Read in the user's selection
    std::cin >> selection;
    std::cin.ignore(100,'\n');

    // If the user's selection as invalid..
    if(selection < 1 || selection > options)
      // Display an error message.
      std::cout << "\n  Invalid Entry! Please enter a number from 1 to " << options
                << ".." << std::endl;
  }

  return selection;
}



/* *************************************************
// Prompts for / reads in entry of one of two
// options, specified by the fst and snd choice
// characters. Returns true if fst_choice is
// selected.
//
// @param fst_choice: The first option char
// ( e.g. Y in (Y/N) ).
//
// @param snd_choice: The second option char
// ( e.g. N in (Y/N) ).
//
// @return: True if fst_choice is selected.
//
// *************************************************/
bool tu::confirmChoice(char fst_choice, char snd_choice)
{
  // Confirmation entry.
  char confirmation = '\0';

  // Prompt user to enter confirmation.
  std::cout << "\n  Please confirm (" << fst_choice << '/' << snd_choice << "): ";

  // Read in confirmation.
  std::cin >> confirmation;
  std::cin.ignore(100,'\n');
  std::cout << std::endl;

  // Convert entry to uppercase.
  confirmation = toupper(confirmation);

  // If the user has selected fst_choice, return true.
  if(confirmation == toupper(fst_choice)) return true;
  // If the user has selected snd_choice, return false.
  if(confirmation == toupper(snd_choice)) return false;

  // Display an alert that the entry is invalid.
  std::cout << "\n  Invalid entry! Please enter a \'"
            << fst_choice << "\' or an \'"
            << snd_choice << "\'.." << std::endl;

  // Try again.
  return confirmChoice(fst_choice, snd_choice);
}


/* *************************************************
// Prompts for entry to continue.
\\
// *************************************************/
void tu::continueMenu(void)
{
  // Prompt user to press enter.
  std::cout << "\n  Press enter to continue...";
  // Wait until user continues.
  std::cin.ignore(128,'\n');

  return;
}



/* *************************************************
// Read in and return a natural number, using
// the specified title.
//
// *************************************************/
int tu::readNaturalNum(std::string data_type)
{
  // Location for the user's entry.
  int entry = 0;

  // Prompt for number entry.
  std::cout << "\n\tPlease enter a natural number to initialize the "
       << data_type << ".."
       << "\n\n    Enter number: ";

  // Read in the number.
  std::cin >> entry;
  std::cin.ignore(100, '\n');

  // If the entry is invalid, alert the user and try again.
  if(entry < 0)
    std::cout << "\n\tInvalid entry. Must be a natural number (0,1,2..)..\n"
              << std::endl;
  else
  {
    // Display the user's entry.
    std::cout << "\n      Using " << entry << '.'
              << "\n      Is this correct?\n" << std::endl;

    // Prompt for confirmation. If confirmed,
    // return to calling function.
    if(confirmChoice('Y', 'N')) return entry;

    // Alert the user that the function will execute again.
    else std::cout << "\n  Retrying..\n" << std::endl;
  }

  return readNaturalNum(data_type);
}



/* *************************************************
// Read in and return a whole number, using the
// specified title.
//
// *************************************************/
int tu::readInteger(std::string data_type)
{
  // Location for the user's entry.
  int entry = 0;

  // Prompt for number entry.
  std::cout << "\n\tPlease enter an integer to initialize the "
       << data_type << ".."
       << "\n\n    Enter number: ";

  // Read in the number.
  std::cin >> entry;
  std::cin.ignore(100, '\n');

  // Display the user's entry.
  std::cout << "\n      Using " << entry << '.'
            << "\n      Is this correct?\n" << std::endl;

  // Prompt for confirmation. If confirmed,
  // return to calling function.
  if(confirmChoice('Y', 'N')) return entry;

  // Alert the user that the function will execute again.
  else std::cout << "\n  Retrying..\n" << std::endl;

  return readNaturalNum(data_type);
}



/* *************************************************
// Reads in various types of char[] data from
// the console.
//
// *************************************************/
void tu::readValue( std::string data_loc,
                std::string data_type,
                int max_len )
{
  // Display prompt to enter a data_loc.
  std::cout << "\n  Please enter the " << data_type << ": ";

  // Read in the data_loc.
  std::getline(std::cin, data_loc);
  std::cout << std::endl;

  // Display recieved data_loc.
  std::cout << "\n      Using " << data_type << ": " << data_loc
            << "\n\n      Is this correct?" << std::endl;

  // Prompt for confirmation. If confirmed,
  // return to calling function.
  if(confirmChoice('Y', 'N')) return;

  // Display alert that the function will execute again.
  std::cout << "  Trying again!" << std::endl;

  // Keep trying.
  return readValue(data_loc, data_type, max_len);
}